<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>protoflex</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">protoflex</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> protoflex</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#protoflex" id="protoflex" style="color: inherit; text-decoration: none;">
					<h1>Protoflex</h1>
				</a>
				<p>Welcome to Protoflex documentation!  </p>
				<a href="#quick-start" id="quick-start" style="color: inherit; text-decoration: none;">
					<h1>Quick start:</h1>
				</a>
				<a href="#reading-deserializing" id="reading-deserializing" style="color: inherit; text-decoration: none;">
					<h2>Reading (deserializing)</h2>
				</a>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> PB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'protoflex'</span>)
<span class="hljs-built_in">console</span>.log(PB.fromHex(<span class="hljs-string">'082a'</span>).int32(<span class="hljs-number">1</span>))  <span class="hljs-comment">// 42</span></code></pre>
				<p>or via <a href="#json-api">JSON API</a> (<em>not recommended</em>, <a href="#from-message-to-json">why?</a>):</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> PB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'protoflex'</span>)
<span class="hljs-built_in">console</span>.log(PB.fromHex(<span class="hljs-string">'082a'</span>).toJSON()) <span class="hljs-comment">// { '1': '42' }</span></code></pre>
				<a href="#writing-serializing" id="writing-serializing" style="color: inherit; text-decoration: none;">
					<h2>Writing (serializing)</h2>
				</a>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> PB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'protoflex'</span>)
<span class="hljs-keyword">let</span> msg = PB
    .create()
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>)
<span class="hljs-built_in">console</span>.log(msg.serialize())  <span class="hljs-comment">// [0x08, 0x2a]</span></code></pre>
				<p>or via <a href="#json-api">JSON API</a>:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> PB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'protoflex'</span>)
<span class="hljs-keyword">let</span> msg = PB.fromJson({
    <span class="hljs-number">1</span>: <span class="hljs-number">42</span>
})
<span class="hljs-built_in">console</span>.log(msg.serialize())  <span class="hljs-comment">// [0x08, 0x2a]</span></code></pre>
				<a href="#main-helper-functions" id="main-helper-functions" style="color: inherit; text-decoration: none;">
					<h1>Main helper functions</h1>
				</a>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> PB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'protoflex'</span>)</code></pre>
				<p>then you can do:</p>
				<a href="#codecreatecode" id="codecreatecode" style="color: inherit; text-decoration: none;">
					<h2><code>.create()</code></h2>
				</a>
				<p>Returns a new empty <code>InputMessage</code>, refer to <a href="#writing-in-functional-style">Functional API</a></p>
				<a href="#codeparsedata-numbercode" id="codeparsedata-numbercode" style="color: inherit; text-decoration: none;">
					<h2><code>.parse(data: number[])</code></h2>
				</a>
				<p>Parses array of bytes as a <code>OutputMessage</code>, refer to <a href="#reading-in-functional-style">Functional API</a></p>
				<a href="#codefromhexobjectcode" id="codefromhexobjectcode" style="color: inherit; text-decoration: none;">
					<h2><code>.fromHex(object)</code></h2>
				</a>
				<p>Parses string as hexadecimal to <code>OutputMessage</code> refer to <a href="#reading-in-functional-style">Functional API</a></p>
				<a href="#codefromjsonobjectcode" id="codefromjsonobjectcode" style="color: inherit; text-decoration: none;">
					<h2><code>.fromJson(object)</code></h2>
				</a>
				<p>Creates an <code>InputMessage</code> from JSON, refer to <a href="#json-api">JSON API</a></p>
				<a href="#coderequire39protoflexutils39code" id="coderequire39protoflexutils39code" style="color: inherit; text-decoration: none;">
					<h2><code>require(&#39;protoflex/utils&#39;)</code></h2>
				</a>
				<p>See API reference for <a href="./modules/_utils_d_.html">utils.d.ts</a></p>
				<a href="#functional-api" id="functional-api" style="color: inherit; text-decoration: none;">
					<h1>Functional API</h1>
				</a>
				<a href="#reading-in-functional-style" id="reading-in-functional-style" style="color: inherit; text-decoration: none;">
					<h2>Reading in functional style</h2>
				</a>
				<p>There are <code>.&lt;type&gt;(key, ?index = 0)</code> methods for all (supported) Protobuf types,
					where <code>&lt;type&gt;</code> is a Protobuf type (e.g. <code>int32</code>), which return value in the
				given field interpreted as given type.<br>For convenience, there&#39;s also <code>hex</code> type that returns <code>bytes</code> as a hexadecimal string</p>
				<p>You can use <code>.get(key, type, ?index)</code>, which works exactly the same.</p>
				<p>Also, there are some service methods:</p>
				<a href="#coderepeatedkey-typecode" id="coderepeatedkey-typecode" style="color: inherit; text-decoration: none;">
					<h3><code>.repeated(key, type)</code></h3>
				</a>
				<p>Declare some field as repeated.</p>
				<p>Protobuf version 3 declares a new, more efficient way to store repeated
					elements by storing them in a single length-delimited field.
					However, this increases the complexity of parsing them â€” it is not actually
					possible without knowing the type of items.
				Thus, to provide possibility of parsing those fields, this method is available.</p>
				<p>This method internally converts the packed repeated to a normal repeated
				(of course, if it was packed in the first place):</p>
				<pre><code class="language-javascript">msg.array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// field is not varint</span>
msg.repeated(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>).array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// ok</span></code></pre>
				<a href="#codeknowncode" id="codeknowncode" style="color: inherit; text-decoration: none;">
					<h3><code>.known()</code></h3>
				</a>
				<p>In Protobuf, when a field has its default value (e.g. <code>0</code> for numbers,
					empty strings, messages, etc), it may not be present in wire. Thus, to handle
				these cases, you can either <code>try/catch</code> calls, or use <code>.known(...items)</code>. </p>
				<p>It accepts varargs of:</p>
				<ul>
					<li><code>number</code> will be interpreted as a known-for-sure untyped field key</li>
					<li><code>number[]</code> will be interpreted as a known-for-sure untyped field keys</li>
					<li><code>{ &lt;key&gt;: string }</code> will be interpreted as: <code>&lt;key&gt;</code> field is of the given type</li>
					<li><code>{ &lt;key&gt;: string[] }</code> will be interpreted as: <code>&lt;key&gt;</code> field is one of the given types</li>
				</ul>
				<a href="#codearraykey-typecode" id="codearraykey-typecode" style="color: inherit; text-decoration: none;">
					<h3><code>.array(key, type)</code></h3>
				</a>
				<p>Returns array of fields with key <code>key</code> interpreted as <code>type</code></p>
				<a href="#codeiterkey-typecode" id="codeiterkey-typecode" style="color: inherit; text-decoration: none;">
					<h3><code>.iter(key, type)</code></h3>
				</a>
				<p>Returns iterator of items in <code>key</code> field interpreted as <code>type</code>, which is compatible
				with both <code>for..of</code> and <code>.next()</code> flows.</p>
				<a href="#codelengthkeycode" id="codelengthkeycode" style="color: inherit; text-decoration: none;">
					<h3><code>.length(key)</code></h3>
				</a>
				<p>Returns number of items with given key</p>
				<a href="#codehaskey-index-ignoreknowncode" id="codehaskey-index-ignoreknowncode" style="color: inherit; text-decoration: none;">
					<h3><code>.has(key, ?index, ?ignoreKnown)</code></h3>
				</a>
				<p>Returns if message has field with key <code>key</code> and index <code>index</code>.
					If <code>ignoreKnown</code> is set, will return <code>false</code> for fields that are declared in <code>.known()</code> but
				not present in actual message.</p>
				<a href="#codetypekey-indexcode" id="codetypekey-indexcode" style="color: inherit; text-decoration: none;">
					<h3><code>.type(key, ?index)</code></h3>
				</a>
				<p>Returns type of has field with key <code>key</code> and index <code>index</code>.</p>
				<a href="#codetojsoncode" id="codetojsoncode" style="color: inherit; text-decoration: none;">
					<h3><code>.toJSON()</code></h3>
				</a>
				<p>Converts message to JSON, refer to <a href="#json-api">JSON API</a></p>
				<a href="#codetoinputcode" id="codetoinputcode" style="color: inherit; text-decoration: none;">
					<h3><code>.toInput()</code></h3>
				</a>
				<p>Converts the message to InputMessage, to allow modifying it.</p>
				<p><strong>Note</strong>: You likely won&#39;t be able to use <code>InputMessage.get</code>,
					because types will be erased down to primitives. If you will need to get the
				field values later, keep the original message at hand.</p>
				<p><strong>Note</strong>: When converted back to the wire, it may not be exactly the same
					as the original message, even if no changes were made. Particularly, order of the
					fields may not be preserved, empty fields may be removed
					(use <code>InputMessage.keepDefault</code> to avoid that), and non-packed
					primitives may get packed. Still, the resulting message should stay
				<em>compatible</em> with the original one.</p>
				<a href="#packed-repeated" id="packed-repeated" style="color: inherit; text-decoration: none;">
					<h4>Packed repeated</h4>
				</a>
				<p>If your message contains packed repeated fields, you have to declare
					them using <code>.repeated()</code> <em>before</em> using <code>.toInput()</code> to make them available
				in the input message. </p>
				<a href="#writing-in-functional-style" id="writing-in-functional-style" style="color: inherit; text-decoration: none;">
					<h2>Writing in functional style</h2>
				</a>
				<p>Similarly, there are <code>.&lt;type&gt;(key, value, ?index = 0)</code> methods for all
					(supported) Protobuf types, where <code>&lt;type&gt;</code> is a Protobuf type (e.g. <code>int32</code>),
				which return the very same message to support chaining. Example:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> msg = PB.create()
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>)
    .int32(<span class="hljs-number">2</span>, <span class="hljs-number">44</span>)
    .toWire()</code></pre>
				<p>Similarly you can write nested messages:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> msg = PB.create()
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>)
    .message(<span class="hljs-number">1</span>, (msg) =&gt; {
        msg
            .string(<span class="hljs-number">1</span>, <span class="hljs-string">'such flex'</span>)
            .string(<span class="hljs-number">2</span>, <span class="hljs-string">'much wow'</span>)
    })
    .int32(<span class="hljs-number">2</span>, <span class="hljs-number">44</span>)
    .toWire()</code></pre>
				<a href="#repeated" id="repeated" style="color: inherit; text-decoration: none;">
					<h3>Repeated</h3>
				</a>
				<a href="#adding-items" id="adding-items" style="color: inherit; text-decoration: none;">
					<h4>Adding items</h4>
				</a>
				<p>There are two ways of adding repeated items:</p>
				<p>If you are adding items one-by-one, you can use <code>.append(key, value, ?type)</code> method,
					which works similarly to <code>.push()</code> method of native arrays
				(but can&#39;t handle multiple items at once)</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> msg = PB.create()
    .append(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>, <span class="hljs-string">'int32'</span>)
    .append(<span class="hljs-number">1</span>, <span class="hljs-number">43</span>, <span class="hljs-string">'int32'</span>)
    .append(<span class="hljs-number">1</span>, <span class="hljs-number">44</span>, <span class="hljs-string">'int32'</span>)
    .array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// [42, 43, 44]</span></code></pre>
				<p>Type argument is optional, but is strongly recommended.</p>
				<p>Alternatively, you can use <code>index</code> parameter in <code>.&lt;type&gt;</code> methods:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> msg = PB.create()
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>, <span class="hljs-number">0</span>)
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">43</span>, <span class="hljs-number">1</span>)
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">44</span>, <span class="hljs-number">2</span>)
    .array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// [42, 43, 44]</span></code></pre>
				<p>This way you can set items randomly</p>
				<blockquote>
					<p>Note that even though it can be used as a sparse, when serializing, empty fields are ignored,
					and resulting message will not have same order. </p>
					<p>Example: <code>[1, undefined, 1]</code> will be encoded as <code>[1, 1]</code>, and thus re-decoded as <code>[1, 1]</code> </p>
				</blockquote>
				<a href="#deleting-items" id="deleting-items" style="color: inherit; text-decoration: none;">
					<h4>Deleting items</h4>
				</a>
				<p>For removing items there&#39;s a <code>.clear(key, ?index)</code> method. Negative <code>index</code>es are supported
				(-1 is last, -2 is pre-last etc.), and when it is missing, the whole array is cleared:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> msg = PB.create()
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>, <span class="hljs-number">0</span>)
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">43</span>, <span class="hljs-number">1</span>)
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">44</span>, <span class="hljs-number">2</span>)
    .int32(<span class="hljs-number">1</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>)
msg.array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// [42, 43, 44, 45]</span>
msg.clear(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>).array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// [42, 43, 44]</span>
msg.clear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// [42, 44]</span>
msg.clear(<span class="hljs-number">1</span>).array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// []</span></code></pre>
				<blockquote>
					<p>Note that empty arrays are ignored when serializing to the wire
					because of how Protobuf works</p>
				</blockquote>
				<a href="#accessing-items" id="accessing-items" style="color: inherit; text-decoration: none;">
					<h4>Accessing items</h4>
				</a>
				<p>Let&#39;s say you have this Protoflex object:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> msg = PB.create()
    .append(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>, <span class="hljs-string">'int32'</span>)
    .append(<span class="hljs-number">1</span>, <span class="hljs-number">43</span>, <span class="hljs-string">'int32'</span>)
    .append(<span class="hljs-number">1</span>, <span class="hljs-number">44</span>, <span class="hljs-string">'int32'</span>)
    .array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>) <span class="hljs-comment">// [42, 43, 44]</span></code></pre>
				<p>You can access array items in two ways, first is <code>index</code> parameter in <code>.get()</code> method, and
				second is <code>.array(key, ?type)</code> method, which accepts a <code>key</code> and optionally field type.</p>
				<p>So, code for accessing <code>N</code>th item will look like this:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> eq = msg.array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>)[N] === msg.get(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>, N) <span class="hljs-comment">// true</span></code></pre>
				<p>However, for random access you should use <code>.get()</code> method, and fot iterating - <code>.iter()</code></p>
				<a href="#iterating-over-items" id="iterating-over-items" style="color: inherit; text-decoration: none;">
					<h4>Iterating over items</h4>
				</a>
				<p>Continuing with same object from previous part, you may also want to iterate over all values.
					This is also possible with <code>.iter(key, ?editable, ?type)</code> method. You may wonder about
					<code>editable</code> parameter, but it is pretty straightforward. When it is <code>true</code>, iterables
					are <code>{ get() {...}, set() {...} }</code> item references, and when <code>false</code> iterables are simply
				field values. By default they are not editable.</p>
				<p>It can be used both in <code>for..of</code> and as a plain iterator (<code>.next()</code>):</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">of</span> msg.iter(<span class="hljs-number">1</span>)) {
    <span class="hljs-built_in">console</span>.log(it) <span class="hljs-comment">// 42, 43, 44 consequently</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> it <span class="hljs-keyword">of</span> msg.iter(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)) {
    <span class="hljs-built_in">console</span>.log(it.get()) <span class="hljs-comment">// 42, 43, 44 consequently</span>
    it.set(it.get() + <span class="hljs-number">1</span>)
}
<span class="hljs-built_in">console</span>.log(msg.array(<span class="hljs-number">1</span>, <span class="hljs-string">'int32'</span>)) <span class="hljs-comment">// [43, 44, 45]</span></code></pre>
				<a href="#keep-default" id="keep-default" style="color: inherit; text-decoration: none;">
					<h3>Keep default</h3>
				</a>
				<p>When serializing to the wire, by default fields with default values
				(that is, <code>0</code> for numbers, empty messages, arrays, strings, etc.):</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> msg = PB.fromJson({ <span class="hljs-number">1</span>: <span class="hljs-number">0</span> }).toHex()
<span class="hljs-built_in">console</span>.log(PB.fromHex(msg)) <span class="hljs-comment">// {}</span></code></pre>
				<p>In some cases this is not desirable (e.g. when targeting some broken decoders),
				and you can force Protoflex to write default values to the wire as well:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> msg = PB.fromJson({ <span class="hljs-number">1</span>: <span class="hljs-number">0</span> }).keepDefault().toHex()
<span class="hljs-built_in">console</span>.log(PB.fromHex(msg)) <span class="hljs-comment">// { 1: 0 }</span></code></pre>
				<a href="#json-api" id="json-api" style="color: inherit; text-decoration: none;">
					<h1>JSON API</h1>
				</a>
				<a href="#from-message-to-json" id="from-message-to-json" style="color: inherit; text-decoration: none;">
					<h2>From message to JSON</h2>
				</a>
				<p>Protoflex provides a convenient JSON API. Basically, it enables you to treat
					Protobuf messages just like plain Javascript objects. However, it implies some
				limitations: there are no type/presence checks.</p>
				<p>As you have already seen in <a href="#quick-start">Quick Start</a>, JSON API returns plain JS objects
					with numbers as keys (which are however treated as strings by JS engine) and
					values. All number values are represented as a string, and only primitive types
					are parsed. Also, parsing nested messages or repeated integers/fractions may be
				inaccurate because of how Protobuf handles them.</p>
				<p>Another thing is using JSON API to convert from output message to input
					(i.e. <code>PB.fromJson(msg.toJSON())</code>). This <strong>should never be done</strong>!
					Not only the points mentioned before are still valid, fixed32/64 types
					will be written to the wire as varint, and will make the message <strong>incompatible</strong>
				with the original one.</p>
				<p>Instead, use <code>msg.toInput()</code>, which tries to preserve as much information
				as possible for a <em>compatible</em> serialization.</p>
				<a href="#from-json-to-message" id="from-json-to-message" style="color: inherit; text-decoration: none;">
					<h2>From JSON to message</h2>
				</a>
				<p>This direction of conversion is much more flexible than the opposite.</p>
				<p>As input, JSON API takes a plain JS object (or JSON in string) like this:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> a = fromJson({
    <span class="hljs-number">1</span>: <span class="hljs-string">'hi'</span>,
    <span class="hljs-number">2</span>: <span class="hljs-number">42</span>
})</code></pre>
				<blockquote>
					<p>Note that Protoflex ignores any non-numeric keys.</p>
				</blockquote>
				<a href="#json-api-types" id="json-api-types" style="color: inherit; text-decoration: none;">
					<h3>JSON API types</h3>
				</a>
				<p>By default, Protobuf types are inferred from input type:</p>
				<table>
					<thead>
						<tr>
							<th>JS type</th>
							<th>Inferred Protobuf type</th>
						</tr>
					</thead>
					<tbody><tr>
							<td><code>number</code></td>
							<td><code>int32</code> if whole number, else <code>float</code> (note that <code>.0</code> does not make number a fraction)</td>
						</tr>
						<tr>
							<td><code>string</code></td>
							<td><code>string</code></td>
						</tr>
						<tr>
							<td><code>boolean</code></td>
							<td><code>bool</code></td>
						</tr>
						<tr>
							<td><code>BigInt</code></td>
							<td><code>int64</code></td>
						</tr>
						<tr>
							<td><code>Buffer</code>, <code>Uint8Array</code></td>
							<td><code>bytes</code></td>
						</tr>
						<tr>
							<td><code>Long</code></td>
							<td><code>int64</code> or <code>uint64</code>, depending on <code>.unsigned</code></td>
						</tr>
						<tr>
							<td><code>&lt;plain object&gt;</code></td>
							<td><code>message</code></td>
						</tr>
				</tbody></table>
				<a href="#explicit-types" id="explicit-types" style="color: inherit; text-decoration: none;">
					<h4>Explicit types</h4>
				</a>
				<p>Surely, you may want to cast a value to some explicit type,
				so this syntax is supported:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> a = fromJson({
    <span class="hljs-number">1</span>: <span class="hljs-string">'hi'</span>,
    <span class="hljs-number">2</span>: {
        <span class="hljs-attr">uint32</span>: <span class="hljs-number">42</span>
    }
})</code></pre>
				<p>Here, field <code>2</code> will have type <code>uint32</code> instead of default <code>int32</code>. </p>
				<a href="#difference-between-explicit-types-and-sub-messages" id="difference-between-explicit-types-and-sub-messages" style="color: inherit; text-decoration: none;">
					<h4>Difference between explicit types and sub-messages</h4>
				</a>
				<p>You may now wonder how Protoflex differs sub-messages and this syntax. </p>
				<p>Actually, everything is quite straightforward: if Protoflex encounters
					a key with a <strong>special meaning</strong>, it is treated how intended
				(those keys are all supported protobuf types, <code>value</code> and <code>unpacked</code>, more about it below).</p>
				<p>If it encounters protobuf type as a key, its value is treated as this type.<br>If it encounters <code>value</code> as a key, its value is treated like it was put simply as
				value in message (meaning the type will be inferred).<br>Otherwise, it is treated like a sub-message.</p>
				<blockquote>
					<p>Modifiers like <code>unpacked</code> <em>(more can be added without breaking compatibility)</em>
					do not affect inferred type.</p>
				</blockquote>
				<blockquote>
					<p>Putting <code>value</code> has <strong>higher priority</strong> that putting a type, and putting
					multiple types will result in undefined behaviour</p>
				</blockquote>
				<a href="#repeated-fields" id="repeated-fields" style="color: inherit; text-decoration: none;">
					<h3>Repeated fields</h3>
				</a>
				<p>Encoding arrays aka <code>repeated</code> fields using JSON API is also very intuitive: </p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> a = fromJson({
    <span class="hljs-number">1</span>: <span class="hljs-string">'hi'</span>,
    <span class="hljs-number">2</span>: [<span class="hljs-number">42</span>, <span class="hljs-number">43</span>]
})</code></pre>
				<p>Here, field <code>2</code> will be repeated in resulting message twice with given values.</p>
				<a href="#unpacked-fields" id="unpacked-fields" style="color: inherit; text-decoration: none;">
					<h3>Unpacked fields</h3>
				</a>
				<p>As you might know, some repeated fields in protobuf can
					be packed (see <a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">here</a>),
					which could be unsupported by target deserializer. Thus, you can declare it using a
				modifier <code>unpacked</code>:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">let</span> a = fromJson({
    <span class="hljs-number">1</span>: <span class="hljs-string">'hi'</span>,
    <span class="hljs-number">2</span>: {
        <span class="hljs-attr">value</span>: [<span class="hljs-number">42</span>, <span class="hljs-number">43</span>],
        <span class="hljs-attr">unpacked</span>: <span class="hljs-literal">true</span>
    }
})</code></pre>
				<p>A bit larger code, but it is needed rarely anyway.</p>
				<a href="#api-reference" id="api-reference" style="color: inherit; text-decoration: none;">
					<h1>API reference:</h1>
				</a>
				<ul>
					<li><code>protoflex</code>: <a href="./modules/_index_d_.protoflex.html">index.d.ts#protoflex</a></li>
					<li><code>protoflex/utils</code>: <a href="./modules/_utils_d_.html">utils.d.ts</a></li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_d_.html">&quot;index.d&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_utils_d_.html">&quot;utils.d&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>